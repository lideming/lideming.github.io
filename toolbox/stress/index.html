<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/vue@3.2.26/dist/vue.global.prod.js"></script>
    <title>JS Stress</title>
    <style>
        body {
            text-align: center;
            font-family: monospace;
        }

        button {
            padding: 10px;
            margin: 10px;
        }
    </style>
</head>

<body>
    <div class="app">
        <h1>JS Stress / Benchmark</h1>
        <h2>CPU Stress</h2>
        <div>Iteration count: {{iterationCount}} million</div>
        <div>Iteration speed (total): {{iterationSpeed.toFixed(3)}} million/s</div>
        <div>Iteration speed (per worker): {{ !iterationSpeedPerWorker ? 'N/A' : iterationSpeedPerWorker.toFixed(3)}} million/s</div>

        <h3>Workers Control</h3>
        <div>Worker count: {{workerCount}} ({{pendingCount}} pending)</div>
        <button @click="removeAllWorkers">-ALL</button>
        <button @click="removeWorker">-1</button>
        <button @click="addWorker">+1</button>
        <button @click="addCpuCountWorkers">+{{cpuCount}}</button>

        <h2>Memory Stress</h2>
        <div>Allocated Memory: {{allocatedMemory}} MB{{ memoryError && ` (${memoryError})` }}</div>
        <button @click="clearMemory">-ALL</button>
        <button @click="addMemory(128)">+128 MB</button>
        <button @click="addMemory(1024)">+1024 MB</button>
    </div>
    <script>
        const { createApp, ref } = Vue;
        createApp({
            setup() {
                const workerCount = ref(0);
                const pendingCount = ref(0);
                const workers = [];
                const iterationCount = ref(0);
                const cpuCount = navigator.hardwareConcurrency;
                function addWorker() {
                    const worker = new Worker('./worker.js');
                    workers.push(worker);
                    let pending = true;
                    pendingCount.value++;
                    workerCount.value++;
                    worker.addEventListener('error', (e) => {
                        workers.splice(workers.indexOf(worker), 1);
                        workerCount.value--;
                        if (pending) pendingCount.value--;
                        console.error('worker error', e);
                    });
                    worker.addEventListener('message', (e) => {
                        if (e.data == 'iteration') {
                            iterationCount.value++;
                        } else if (e.data == 'ready') {
                            pendingCount.value--;
                            pending = false;
                        }
                    });
                    worker.postMessage({ action: 'cpu' })
                    resetCounter();
                }

                const iterationSpeed = ref(0);
                const iterationSpeedPerWorker = ref(0);
                let startTime = Date.now();
                setInterval(() => {
                    const now = Date.now();
                    iterationSpeed.value = iterationCount.value / ((now - startTime) / 1000);
                    iterationSpeedPerWorker.value = !workerCount.value ? 0 : (iterationSpeed.value / workerCount.value);
                }, 1000);

                function resetCounter() {
                    startTime = Date.now();
                    iterationCount.value = 0;
                }

                /** @type {Array<{ worker: Worker; size: number; }>} */
                const memoryWorkers = [];
                const allocatedMemory = ref(0);
                const memoryError = ref('');
                function addMemory(size) {
                    const item = getWorker(size);
                    item.size += size;
                    item.worker.postMessage({
                        action: 'mem',
                        size,
                    });
                }
                function getWorker(availableSize) {
                    let worker = memoryWorkers.find(w => (1024 - w.size) >= availableSize);
                    if (!worker) {
                        worker = {
                            worker: new Worker('./worker.js'),
                            size: 0
                        };
                        worker.worker.addEventListener('message', (e) => {
                            if (e.data.action == 'mem') {
                                allocatedMemory.value += e.data.size;
                            }
                        });
                        worker.worker.addEventListener('error', (e) => {
                            memoryError.value = e.message;
                        })
                        memoryWorkers.push(worker);
                    }
                    return worker;
                }
                function clearMemory() {
                    memoryError.value = '';
                    allocatedMemory.value = 0;
                    while (memoryWorkers.length) {
                        memoryWorkers.pop().worker.terminate();
                    }
                }


                return {
                    workerCount,
                    pendingCount,
                    cpuCount,
                    iterationCount,
                    iterationSpeed,
                    iterationSpeedPerWorker,
                    addWorker,
                    addCpuCountWorkers() {
                        for (let i = 0; i < cpuCount; i++) {
                            addWorker();
                        }
                    },
                    removeWorker() {
                        if (workers.length) {
                            workers.pop().terminate();
                            workerCount.value--;
                            resetCounter();
                        }
                    },
                    removeAllWorkers() {
                        while (workers.length) {
                            workers.pop().terminate();
                        }
                        workerCount.value = 0;
                        resetCounter();
                    },

                    allocatedMemory,
                    memoryError,
                    addMemory,
                    clearMemory,
                }
            }
        }).mount('.app');
    </script>
</body>

</html>